
    At any stage, you may want to undo something. Here. we'll review two basic tools
for undoing changes that you've made. Be careful, because you can't always undo some
of the undos. This is one of the few areas in Git where you may lose some work if you
do it wrong.
    We've all done it. Perhaps you didn't have enough coffee that morning, or it was
just before lunch. Somehow, though, that bug got into the repository, and now you
need to get it out. Luckily, git revert is just the scalpel you need to extract the
bad commit. The "revert" command works like so : it basically reverses whatever 
changes made in the commit passed in by creating a new commit. So, if you want to
revert the last comit you just made on your current branch, you can use "git revert
HEAD". You can also pass in any SHA for any commit to revert those changes. Of course,
if the commit that you want to revert doesn't apply cleanly you're going to have to 
manually resolve the merge. A helpful option is the -n or --no-commit flag. This
will simply leave the reverted changes in your working directory and noy automatically
commit them. If you need to edit files further to complete the revert or possibly
revert more than one commit, try out this option
    The other undo command we'll talk about is "git reset". So, git reset changes, at
minimum, where your current branch is pointing. The reset command has three types :
soft, mixed and start. Let's illustrate them by imagining a branch master with this 
series of commits : A - B - C (master), where HEAD points to C and the index matches
C. When we run "git reset --soft B", master (HEAD) now points to B, but the index 
still has the changes from C; git status will show thme as staged. So if we run 
"git commit" at this point, we'll get a new commit with the same changes as C. 
Now, let's do "git reset --mixed B". Once again, master and HEAD point to B, but this
time the index is also modified to match B. If we run "git commit" at this point, 
nothing will hapen since the index matches HEAD. We still have the changes in the
working directory, but since they're not in the index, git status shows them as 
unstaged. To commit them, you would git add and then commit as usual. And finally, 
"--hard" is the same as "--mixed" (it changes your HEAD and index), except that
"--hard" also modifies your working directory. If we're at C and run "git reset --
hard B", then the changes added in C, as well as any uncommitted changes you have,
will be removed, and the files in your working copy will match commit B. Since you
can permanently lose changes this way, you should always run git status before doing
a hard reset to make sure your working directory is clean or that you're okay with
losing your uncommited changes.
    If we consider "git revert" as the "safe" way to undo changes, you can think of
"git reset" as the dangerous method. When you undo with git reset, there is no way
to retrieve the original copy - it is a permanent undo. Care must be taken when using
this tool, as it's one of the only Git commands that has the potential to lose your
work. On the commit-level, resetting is a way to move the tip of a branch to a 
different commit. This can be used to remove commits from the current branch.
    If you made some mistake and you haven't pushed the changes to remote repository,
you can use tools such as "git commit --amend", "git revert" and others. But once 
you've pushed your changes, you cannot change your git history without force-pushing.
    Force-pushing and git reset --hard are highly dangerous and unclean solutions 
when you're working in a shared repository. All commits in the shared repository 
should be considered IMMUTABLE. To keep your repository consistent and keep your
collaborators happy, you should use git revert instead.
