                                    Linked List vs Array vs Binary Tree

1. Data Usage

A. Array

    - Data

B. Linked List

    - Data
    - Pointer to next node

    - Pointer to previous node (*) => Double Linked List

C. Binary Tree

    - Data
    - Pointer to left child
    - Pointer to right child 


Winner : Array                  2nd : Linked List               3rd : Binary Tree

2. Accessing the n-th element

A. Array

    - Array allows random access        |
                                        | =>    One operation needed
    - Index = n                         |

B. Linked List

    - We need to access elements sequentially starting from the first node => N operations needed

     ______________		 ______________						 ______________
    /              \  1 op	/              \  2nd op                 (n-1)th op	/	       \
   |  1st element   | -------> |   2nd element  | --------> ............ ------------> |  n-th element	| => N operations needed
    \______________/		\______________/					\______________/

C. Binary Tree

    - Trees aren't ordered, so there is no n-th element

Winner : Array                  2nd : Linked List               3rd : Binary Tree

3. Finding / Accesing element X

A. Array

    - We need to iterate through the array until we reach X
 
     1   2         n
    --- --- ----- ---
   | A | B | ... | X | => n operations needed, where n is the index of X in the array.
    --- --- ----- ---

    ** In case we order the array, we can use the binary search algorithm

B. Linked List

    - We need to access elements sequentially starting from the first node until we reach X.

     ______________		 ______________						 ______________
    /              \   1 op	/              \   2nd op                (n-1)th op	/	       \
   |       A        | -------> |        B       | --------> ............ ------------> |        X	| => N operations needed, where N is the index of X in the list.
    \______________/		\______________/					\______________/

C. Binary Tree
    
            ---                            In most of the cases, the traversal of a binary tree is faster than the one of an array
           | C |                                or linked list because of the decreased number of operations.
            ---
         /       \ 1 op                    For instance, let's say that we have the set {C, A, L, E, C, X} represented as an array,
        /         \                             a linked list and a binary tree, with X being the last element. 
      ---         ---
     | A |       | L |                     X is the last element of a 6-element set => We need to make 6 operations to reach it for 
      ---         ---                           the Array and the Linked List.
               /      \ 2 op               
              /        \                   We take our ordered tree. 
            ---       ---                       
           | E |     | X | => 3 op         We know that X is our last element. The ordering criterion of the tree is the alphabetic order,
            ---       ---                       so X will be the biggest element.
                
    That means that X will be the last right node of the tree, so we can easily reach it by traversing the right part of the tree, by 3 OPERATIONS.

    The worst case of complexity would be when we all the elements in ascending order, creating a linear tree.

    However, the number of operations would be equal to the linked list and array cases = N, the index of X.
            
Winner : Binary Tree / Sorted Array w/ Binary Search           2nd Place : Array / Linked List

3. Insertions

A. Array

    - Pretty straightforward if we have memory allocated for the insertion.
    
    - If there is no allocated memory left, the reallocation of the array is needed, which is very costful
        as the memory needs to be moved.

B. Linked List

    - We need to access elements sequentially starting from the first node until we reach the last one (let's name it A).
        We add a new node and we make it the last, by linking it with A.

    - No memory restriction

    - n accesses needed, where n is the number of nodes.

C. Binary Tree
  
    - We need to access elements sequentially starting from the first node until we reach the last one (let's name it A).
        We add a new node and we make it the last, by linking it with A.

    - Comparision operations needed

    - No memory restriction

    - The worst complexity case is when we have a linear tree = n accesses.

    - The binary tree might be faster because of the decreased accesses needed, but it needs several comparision operations.

Winner : Linked List / Binary Tree      2nd : Array

4. Deletions

A. Array

    - If we to delete an element, we might need to shift the array.

    -> Best Case : We delete the last element => 1 accession
    -> Worst Case : We delete the first element => n accessions + n - 1 moves.

B. Linked List

    - Let's say we want to delete node A.

    - We need to make the previous node of A to link to the next node of A, and free de memory of A.

C. Binary Tree

    -> Best Case : We delete a node without childs, simply by freeing it's memory.
    -> Worst Case : We delete a node with childs, needing to move one of the childs in the place of the deleted parent

Winner : Linked List    2nd : Binary Tree       3rd : Array

5. Set Implementation

A. Array

    - Good data usage
    - Fast 
    - No natural way of implementing the rule of non-repeting elements in a set
    - The array is ordered by indexes (BAD)
    - Really bad inserting and removing
    - Easy union/intersection implementation

B. Linked List

    - Good adding / deleting
    - Ok data usage
    - Gets really slow when a lot of elements are involved
    - Ordered

C. Binary Tree

    - Very good adding
    - May make problems when deleting
    - Fast traversal / find
    - Can't add duplicates

6. Complexities

A. Array

    I. Time Complexity 

                     Average    Worst

    - Access    :    O(1)       O(1)
    - Search    :    O(n)       O(n)
    - Insertion :    O(n)       O(n)
    - Deletion  :    O(n)       O(n)

    II. Space Complexity : O(n)

B. Linked List

    I. Time Complexity 

                     Average      Worst

    - Access    :    O(n)       O(n)
    - Search    :    O(n)       O(n)
    - Insertion :    O(1)       O(1)
    - Deletion  :    O(1)       O(1)

    II. Space Complexity : O(n)

C. Binary Tree

    I. Time Complexity 

                     Average    Worst

    - Access    :    O(log(n))  O(n)
    - Search    :    O(log(n))  O(n)
    - Insertion :    O(log(n))  O(n)
    - Deletion  :    O(log(n))  O(n)

    II. Space Complexity : O(n)


